#include <iostream>
#include <string.h>
#include <unistd.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <netdb.h>
#include <strings.h>
#include "../include/global.h"
#include "../include/control_header_lib.h"
#include "../include/network_util.h"
#include <stdlib.h>
#include <cstdlib>
#include <sys/socket.h>
#include <sys/queue.h>
#include <inttypes.h>
#include "../include/connection_manager.h"
#include "../include/pa3.h"
#include "../include/init.h"
#include <sstream>

#define INFINITY 65535;

using namespace std; /***/

uint16_t Number_of_routers, Periodic_Interval, Router_ID[10], Router_Port1[10], Router_Port2[10], Cost[10], RoutingTable[5][1];
uint16_t Forwarding_Table[5][3];
string init_control_response_payload;
char *Cntrl_resp_data;
int selfID;
uint32_t Router_IP[10];
char buffer[10][INET_ADDRSTRLEN + 1], buffer2[INET_ADDRSTRLEN + 1];
char IP[5][1024];

#define INIT_STATEMENT ""

void init_response(int sock_index)
{
  uint16_t payload_len, response_len;
  char *cntrl_response_header, *cntrl_response_payload, *cntrl_response;

  payload_len = sizeof(INIT_STATEMENT)-1; // Discount the NULL chararcter
  cntrl_response_payload = (char *) malloc(payload_len);
  memcpy(cntrl_response_payload, INIT_STATEMENT, payload_len);

  cntrl_response_header = create_response_header(sock_index, 0, 0, payload_len);

  response_len = CNTRL_RESP_HEADER_SIZE+payload_len;
  cntrl_response = (char *) malloc(response_len);
  /* Copy Header */
  memcpy(cntrl_response, cntrl_response_header, CNTRL_RESP_HEADER_SIZE);
  free(cntrl_response_header);
  /* Copy Payload */
  memcpy(cntrl_response+CNTRL_RESP_HEADER_SIZE, cntrl_response_payload, payload_len);
  free(cntrl_response_payload);

  sendALL(sock_index, cntrl_response, response_len);

  free(cntrl_response);
}


void init_control_response(int sock_index)
{
  uint16_t payload_len, response_len;
  char *cntrl_response_header;
  char *cntrl_response_payload;//[40];
  char *cntrl_response;
  int i,j;
  int copied=0;
  cntrl_response_payload=(char *)malloc(sizeof(uint16_t)*20);
  
  printf("size of unit16 %u \n", sizeof(uint16_t));
  int count=0;
  
  for(i=0;i<Number_of_routers;i++)
  {
    for(j=0;j<3;j++)
    {
      uint16_t temp=htons(Forwarding_Table[i][j]);
      printf("size of temp %u \n", sizeof(temp));
      memcpy(&cntrl_response_payload[2*count], &temp, 2);
      copied+=sizeof(temp);
      count++;
      if(j==0)
      { //padding
      uint16_t temp2=0;
      uint16_t temp3=htons(temp2);
      memcpy(&cntrl_response_payload[2*count], &temp3, 2);
      printf("size of temp3 %u \n", sizeof(temp3));
      copied+=2;//sizeof(temp3);
      count++;
      }      
    }
  }
  payload_len=8*Number_of_routers;//.size();//-1;
  printf(" Size of Payload %u\n", payload_len);
  printf("Payload DATA %s\n", cntrl_response_payload);
  
  cntrl_response_header = create_response_header(sock_index, 0, 0, payload_len);

  response_len = CNTRL_RESP_HEADER_SIZE+payload_len;
  cntrl_response = (char *) malloc(response_len);
  
  memcpy(cntrl_response, cntrl_response_header, CNTRL_RESP_HEADER_SIZE);
  free(cntrl_response_header);
  
  memcpy(cntrl_response+CNTRL_RESP_HEADER_SIZE, cntrl_response_payload, payload_len);
  
  sendALL(sock_index, cntrl_response, response_len);

  free(cntrl_response);
}


/**Reference: https://stackoverflow.com/questions/4716389/c-convert-uint32-ip-address-to-text-x-x-x-x**/
char* GetIPString(uint32_t x, int i) 
{   
    //buffer2="";
    memset(buffer2, 0,sizeof(buffer2));
    inet_ntop(AF_INET, &x, buffer2, sizeof(buffer2));
    reverseWords(buffer2);
    cout<< "IP Buffer:"<<buffer2<<endl;
    strncpy(IP[i], buffer2, sizeof(buffer2));
    return buffer2;
}

void PrintRoutingTable()
{
  int i;
  for(i=0;i<5;i++)
  {
    cout<<"selfID -> i :"<<RoutingTable[0][i]<<endl;
  }
}

void PrintForwardingTable()
{
  int i,j;
  printf("Router ID \t Next Hop \t Cost \t\n");
  
  for(i=0;i<Number_of_routers;i++)
  {
    for(j=0;j<3;j++)
    {
      printf("Forwarding_Table: %d",Forwarding_Table[i][j]);
    } printf("\n");
  }
  printf("payload length %u \n",init_control_response_payload.size());
  cout<<endl<<"payload"<<init_control_response_payload<<endl;
}

void get_Routing_Table()
{
  int i;
  for(i=0;i<Number_of_routers;i++)
  {
    if(Cost[i]==0)
    {
      selfID=i;
      RoutingTable[i][0]=Router_ID[i];
      Forwarding_Table[i][0]=Router_ID[i];
      Forwarding_Table[i][1]=Router_ID[i];
      Forwarding_Table[i][2]=Cost[i];
    }
    else if(Cost[i]==65535 || Cost[i]<0)
    {
      RoutingTable[i][0]=INFINITY;
      Forwarding_Table[i][0]=Router_ID[i];
      Forwarding_Table[i][1]=Cost[i];
      Forwarding_Table[i][2]=Cost[i];
    }
    else
    {
      RoutingTable[i][0]=Cost[i];
      Forwarding_Table[i][0]=Router_ID[i];
      Forwarding_Table[i][1]=Router_ID[i];
      Forwarding_Table[i][2]=Cost[i];
    }
  }

  PrintForwardingTable();
}

void printIP()
{
  int i;
  for(i=0;i<5;i++)
  {
    cout<<"IP:"<<IP[i]<<endl;
  }
}


bool control_recv_hook(int sock_index)
{   //printf("IN CONTROL_RECV_HOOK\n");
    char *cntrl_header, *cntrl_payload;
    //string cntrl_header;
    uint8_t control_code;
    int payload_len;
    //uint16_t i;

    /* Get control header */
    cntrl_header = (char *) malloc(sizeof(char)*CNTRL_HEADER_SIZE);
    bzero(cntrl_header, CNTRL_HEADER_SIZE);
    //printf("Calling recv all\n");
    if(recvALL(sock_index, cntrl_header, CNTRL_HEADER_SIZE) < 0){
        remove_control_conn(sock_index);
        free(cntrl_header);
        return FALSE;
    }

    /* Get control code and payload length from the header */
    #ifdef PACKET_USING_STRUCT
       BUILD_BUG_ON(sizeof(struct CONTROL_HEADER) != CNTRL_HEADER_SIZE); // This will FAIL during compilation itself; See comment above.

        struct CONTROL_HEADER *header = (struct CONTROL_HEADER *) cntrl_header;
        control_code = header->control_code;
        payload_len = ntohs(header->payload_len);
    #endif
    #ifndef PACKET_USING_STRUCT
        memcpy(&control_code, cntrl_header+CNTRL_CONTROL_CODE_OFFSET, sizeof(control_code));
        memcpy(&payload_len, cntrl_header+CNTRL_PAYLOAD_LEN_OFFSET, sizeof(payload_len));
         payload_len = ntohs(payload_len);
    #endif
    
    free(cntrl_header);
    //printf("length:");

    /* Get control payload */
    if(payload_len != 0){ 
        cntrl_payload = (char *) malloc(sizeof(char)*payload_len);
        bzero(cntrl_payload, payload_len);
        
        if(recvALL(sock_index, cntrl_payload, payload_len) < 0){
            remove_control_conn(sock_index);
            free(cntrl_payload);
            return FALSE;
        }
        
    }
    int i, len=0;
        
    switch(control_code){
        case 0: author_response(sock_index);
                break;

        
        case 1: init_response(sock_index);
                int i;
                Number_of_routers=(uint16_t)((uint8_t)cntrl_payload[1] | (uint8_t)cntrl_payload[0]<<8);
                Periodic_Interval=(uint16_t)((uint8_t)cntrl_payload[3] | (uint8_t)cntrl_payload[2]<<8);
                //cout<<"Number_of_routers:"<<Number_of_routers<<" Periodic_Interval:"<<Periodic_Interval<<endl;
                for(i=0;i<Number_of_routers;i++)
                {               
                      Router_ID[i]=(uint16_t)((uint8_t)cntrl_payload[5+i*12] | (uint8_t)cntrl_payload[4+i*12]<<8);
                      cout<<endl;
                      //cout<<"Router ID "<<Router_ID[i]<<endl;
                      Router_Port1[i]=(uint16_t)((uint8_t)cntrl_payload[7+i*12] | (uint8_t)cntrl_payload[6+i*12]<<8);
                      //cout<<"Router Port1 "<<Router_Port1[i]<<endl;
                      Router_Port2[i]=(uint16_t)((uint8_t)cntrl_payload[9+i*12] | (uint8_t)cntrl_payload[8+i*12]<<8);
                      //cout<<"Router Port2 "<<Router_Port2[i]<<endl;
                      Cost[i]=(uint16_t)((uint8_t)cntrl_payload[11+i*12] | (uint8_t)cntrl_payload[10+i*12]<<8);
                      //cout<<"Cost "<<Cost[i]<<endl;
                      Router_IP[i] = (uint32_t)((uint8_t)cntrl_payload[12+i*12] << 24 |(uint8_t)cntrl_payload[13+i*12] << 16 |  (uint8_t)cntrl_payload[14+i*12] << 8  |   (uint8_t)cntrl_payload[15+i*12]);
                      GetIPString(Router_IP[i],i);                      
                } 
              get_Routing_Table();
              printIP();
              break;
              /*createUDPconnection();*/
        case 2: init_control_response(sock_index);
                break;        
               
        /*
        // init_response(sock_index, cntrl_payload);
        
            .........
           ....... 
         ......*/
    }

    if(payload_len != 0) free(cntrl_payload);
    return TRUE;
}


void main_loop()
{
    int selret, sock_index, fdaccept;

    while(TRUE){
        watch_list = master_list;
        selret = select(head_fd+1, &watch_list, NULL, NULL, NULL);

        if(selret < 0)
            ERROR("select failed.");

        /* Loop through file descriptors to check which ones are ready */
        for(sock_index=0; sock_index<=head_fd; sock_index+=1){

            if(FD_ISSET(sock_index, &watch_list)){

                /* control_socket */
                if(sock_index == control_socket){
                    fdaccept = new_control_conn(sock_index);

                    /* Add to watched socket list */
                    FD_SET(fdaccept, &master_list);
                    if(fdaccept > head_fd) head_fd = fdaccept;
                }

                /* router_socket */
                else if(sock_index == router_socket){
                    /*call handler that will call recvfrom() .....*/
                }

                /* data_socket */
                else if(sock_index == data_socket){
                    /*new_data_conn(sock_index);*/
                }

                /* Existing connection */
                else{
                    if(isControl(sock_index)){
                        if(!control_recv_hook(sock_index)) FD_CLR(sock_index, &master_list);
                    }
                    /*else if isData(sock_index);*/
                    else ERROR("Unknown socket index");
                }
            }
        }
    }
}

void init()
{
    control_socket = create_control_sock();

    //router_socket and data_socket will be initialized after INIT from controller

    FD_ZERO(&master_list);
    FD_ZERO(&watch_list);

    /* Register the control socket */
    FD_SET(control_socket, &master_list);
    head_fd = control_socket;

    main_loop();
}

int main(int argc, char **argv)
{
    /*Start Here*/

    CONTROL_PORT=atoi(argv[1]);
    printf("Control port is %u\n", CONTROL_PORT);
    init(); // Initialize connection manager; This will block

    return 0;
}
